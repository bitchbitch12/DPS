# -*- coding: utf-8 -*-
"""DPS_final_ (2).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zLxUHCde6xI_JHCfyYkbiXH5Hi139zMA
"""

!pip install pycryptodome

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad,unpad
import rsa
import getpass
import ipaddress
import hashlib

"""# Database"""

db = {}
ippolicy = {
    ipaddress.ip_network('192.168.1.0/24'):'allow',
    ipaddress.ip_network('10.0.0.0/8'):'deny',
    ipaddress.ip_network('172.16.0.0/12'):'allow',
}

"""# General :"""

def hashed(passw):
  sha256 = hashlib.sha256()
  sha256.update(passw.encode('utf-8'))
  return sha256.hexdigest()


def register(user,passw):
  db[user] = hashed(passw)


def authentic_user(user,password):
  hash_pass = hashed(password)
  stored_pass = db.get(user)
  if stored_pass and hash_pass == stored_pass:
    return True
  else:
    return False

def get_action(ip_address):
    ip = ipaddress.IPv4Address(ip_address)
    for ip_range, action in ip_policy.items():
        if ip in ip_range:
            return action
    return 'default_action'

publickey,privatekey = rsa.newkeys(512)

"""# Sender and Receiver implementation"""

def sender():
  mess = str(input("Enter the message :")).encode()
  p_mess = pad(mess,AES.block_size)
  key = "Dhikshitha19pd09"
  iv = "DPSFINALEXAM19PD"
  cipher = AES.new(key.encode(),AES.MODE_CBC,iv.encode())
  enc_mess = cipher.encrypt(p_mess)
  #key-encypt-rsa
  enc_key=rsa.encrypt(key.encode(), publickey)
  #iv -encrypt-rsa
  enc_iv =rsa.encrypt(iv.encode(),publickey)
  print("Encrypted Message :",enc_mess)
  #to check if in db
  username = str(input("Enter the username :"))
  if username in db:
    print("Existing User")
  else:
    passw = getpass.getpass("Enter the password :")
    register(username,passw)
  ip = '192.168.1.255'
  return enc_mess,enc_key,enc_iv,username,ip

def receiver(enc_mess,ip,user,key1,key2):
  #check ip
  act = get_action(ip)
  if act == 'allow':
    print("Ip authorized")
    pwd = getpass.getpass("Enter the password :")
    flag = authentic_user(user,pwd)
    if flag is True:
      print("The User has been authenticated and receiving message")
      #RSA -- decrypt key
      key=rsa.decrypt(key1, privatekey).decode()
      iv=rsa.decrypt(key2, privatekey).decode()
      #AES decrypt message
      cipher = AES.new(key.encode(), AES.MODE_CBC, iv.encode())
      decrypted_message = cipher.decrypt(enc_mess)
      #unpad the message
      original_message = unpad(decrypted_message, AES.block_size)

      print("Decrypted Message: ", original_message.decode('utf-8'))
    else:
      print("The User is not authenticated")
      return
  else:
    print("Ip not authorized")
    return

print("_______________________")
print("Sender sending message ")
print("_______________________")
enc_mess,key1,key2,user,ip = sender()
print("_______________________")
print("Receiver receiving message ")
print("_______________________")
dec_mess = receiver(enc_mess,ip,user,key1,key2)
print(dec_mess)

"""#RSA"""

alphabets = {}
for i in range(26):
  alphabets[chr(i+97)] = i

def RSA_encrypt(plain, e, n):
  cipher, cipher_text = [], ''
  for i in range(len(plain)):
    c = (alphabets[plain[i]] ** e) % n
    cipher.append(c)
    cipher_text += chr(c+97)
  return cipher, cipher_text

def RSA_decrypt(cipher, d, n):
  plain, plain_text = [], ''
  for i in range(len(cipher)):
    p = (cipher[i] ** d) % n
    plain.append(p)
    plain_text += chr(p+97)
  return plain, plain_text

def find_d(p, q, e):
  n = p*q
  phi = (p-1)*(q-1)
  k = 1
  while True:
    rem = ((k*phi)+1)%e
    d = ((k*phi)+1)/e
    if rem == 0:
      return d
    k += 1

plain = 'THE SKY IS BLUE'
p, q, e = 3, 11, 7
n = p * q
plain=plain.replace(" ", "")
plain=plain.lower()
cipher = RSA_encrypt(plain, e, n)
d = find_d(p, q, e)
decrypt = RSA_decrypt(cipher[0], int(d), n)

print("Plain text: ", plain)
print('Encrypted text: ', cipher)
print('Decrypted text: ', decrypt)

"""#AES"""

!pip install pycryptodome

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad,unpad

#Encryption
message = b"This is a secret message."
key = get_random_bytes(16)
iv = get_random_bytes(16)
cipher = AES.new(key, AES.MODE_CBC, iv)
padded_message = pad(message, AES.block_size)
encrypted_message = cipher.encrypt(padded_message)
print("Encrypted Message:", encrypted_message)

#Decryption
cipher = AES.new(key, AES.MODE_CBC, iv)
decrypted_message = cipher.decrypt(encrypted_message)
original_message = unpad(decrypted_message, AES.block_size)
print("Decrypted Message:", original_message.decode('utf-8'))

"""#SHA"""

import hashlib
encoded = hashlib.sha512(decrypt[1].encode())
print(len(encoded.hexdigest()))
print(encoded.hexdigest())